[TOC]
# 1. 字符串
## 1.1 字符判断
* 头文件`ctype.h` ,可以不用include
* `isalpha`,`isdigit`,`isspace`用于判断字符串

# 2. 排序
## 2.1 sort/qsort/stable_sort
qosrt的实现是快排
``` c++
vector<int> test;
sort(test.begin(); test.end());
int a[20];
sort(a, a + 20);
```
stable_sort是稳定排序，保证相等元素在序列中相对位置不变
## 2.2 set或者map
set和map底层是平衡二叉树或者红黑树，插入之后再遍历其实就是排序的
``` c++
#include <iostream>
#include <string>
#include <stdio.h>
#include <set>
using namespace std;

int main(void) {
    set<int> my_set;
    my_set.insert(11);
    my_set.insert(3);
    my_set.insert(9);
    my_set.insert(1);
    my_set.insert(25);
    for(set<int>::iterator itor = my_set.begin(); itor != my_set.end(); ++itor) {
        cout << iotr << endl;
    }
    return 0;
}
```
# 3. set用法
## 3.1判断某个对象是否在set中的两种方法
``` c++
set<int> my_set;
if(my_set.count(2) == 0) {
    return false;
}
if(my_set.find(2) == my_set.end()) {
    return false;
}
```

# 4. vector用map迭代器初始化，lamda表达式stable_sort
``` c++
    map<char, int>record;
    string input;
    cin >> input;
    for(auto itor = input.begin(); itor < input.end(); ++itor)
    {
        ++record[*itor];
    }
        vector<pair<char,int>> vec(record.begin(),record.end());
        stable_sort(vec.begin(),vec.end(),[](const pair<char,int>& a,const pair<char,int>& b){
            return a.second>b.second;
        });
    
    for(auto itor = vec.begin(); itor < vec.end(); ++itor)
    {
        cout << itor->first;
    }
    cout << endl;
```