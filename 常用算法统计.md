[TOC]
## 1.1素数判断
``` c++
bool is_prime(long input)
{
    if(input <= 1) {
        return false;
    }

    for(int i = 2; i * i <= input; ++i) {
        if(input % i == 0) {
            return false;
        }
    }
    return true;
}
```

## 1.2 闰年判断
  规则：是4的倍数且不是100的倍数，或者是400的倍数
``` c++
bool is_leap_year(int year)
{
    if(year % 4 == 0 && year % 100 != 0) {
        return true;
    }
    if(year % 400 == 0) {
        return true;
    }
    return false;
}
```

## 1.3 字符串匹配----标准库
注意find_first_of是匹配任意一个字符，不是完整字符串，所以要用find，不要搞错了
``` c++
size_t index = input_string.find(sub_string);
if(index != sub_string.npos) {
    cout << "true" << endl;
} else {
    cout << "false" << endl;
}
```
## 1.4 字符串匹配----Boyer-Moore算法

## 1.5 回文字符串
``` c++
#include <iostream>
#include <string>
#include <stdio.h>
#include <set>
#include <string.h>
#include <algorithm>

using namespace std;

int max_palindrome(string &input)
{
    char pad_char = '#';
    char start_char = '$';
    char end_char = '@';
    size_t input_len = input.size();
    size_t malloc_len = input_len * 2 + 5;
    char * new_string = new char[malloc_len];
    int * max_palindrome_len = new int[malloc_len];
    for(int index = 0; index < malloc_len; ++index)
    {
        max_palindrome_len[index] = 0;
    }

    for(int index = 0; index < input_len; ++index) {
        new_string[index * 2 + 1] = pad_char;
        new_string[index * 2 + 2] = input[index];
    }
    new_string[0] = start_char;
    new_string[input.size() * 2 + 1] = pad_char;
    new_string[input.size() * 2 + 2] = end_char;
    new_string[input.size() * 2 + 3] = '\0';

    int max_center_pos = 1;
    int max_right_pos = 1;
    int max_len = 0;
    int max_len_center_pos = 0;
    max_palindrome_len[0] = 1;
    max_palindrome_len[1] = 1;
    for(int index = 2; index < malloc_len; ++index)
    {
        int current_len = 1;
        if(index < max_right_pos) {
            current_len = min(max_right_pos - index, max_palindrome_len[max_center_pos * 2 - index]);
        }

        while(index - current_len >= 0 && new_string[index - current_len] == new_string[index + current_len]) {
            ++current_len;
        }

        max_palindrome_len[index] = current_len;
        if(current_len + index > max_right_pos) {
            max_right_pos = current_len + index;
            max_center_pos = index;
            if(current_len > max_len) {
                max_len = current_len;
                max_len_center_pos = index;
            }
        }
    }

    delete []new_string;
    delete []max_palindrome_len;
    return max_len - 1;
}

int main(void) {
    #ifdef DEBUG_TEST_LYJ
    freopen("input.txt","r", stdin);
    #endif
    string input;
    cin >> input;
    cout << max_palindrome(input) << endl;
    return 0;
} 
```

## 1.6 辗转相除求最大公约数
``` c++
// 传入n必须大于等于m
int get_gcd(int n, int m)
{
    if(m == 0) {
        return n;
    }
    return get_gcd(m, n % m);
}
```

## 1.7 最长子字符串
``` c++
int max_substring(const string &string1, const string &string2)
{
    int str1_len = string1.size();
    int str2_len = string2.size();

    vector<vector<int>> dp_with_end(str1_len, vector<int>(str2_len, 0));
    int max = 0;
    for (int str1_index = 0; str1_index < str1_len; ++str1_index)
    {
        for (int str2_index = 0; str2_index < str2_len; ++str2_index)
        {
            if (string1[str1_index] == string2[str2_index])
            {
                if (str1_index == 0 || str2_index == 0)
                {
                    dp_with_end[str1_index][str2_index] = 1;
                }
                else
                {
                    dp_with_end[str1_index][str2_index] = dp_with_end[str1_index - 1][str2_index - 1] + 1;
                }
                if (max < dp_with_end[str1_index][str2_index])
                {
                    max = dp_with_end[str1_index][str2_index];
                }
            }
        }
    }
    return max;
}
```

## 1.8 最大递增子序列
``` c++
int max_sub(vector<int> &data)
{
    int len = data.size();
    vector<int> dp(len, 1);
    for (int i = 0; i < len; ++i)
    {
        for (int j = 0; j < i; ++j)
        {
            if (data[i] > data[j])
            {
                dp[i] = max(dp[i], dp[j] + 1);
            }
        }
    }
    return *max_element(dp.begin(),dp.end());
}
```

# 2. 数学公式
## 2.1 牛顿迭代法
设f(x) = x^3^ - y
x~n+1~=x~n~ - f(x)/(f^'^(x))= x~n~ - (x^3^ - y) / 3x^2^